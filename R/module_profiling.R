#' Module: UI element to display trelliscope plot of fitted spectra
#'
#' @param id A string denoting the namespace id.
#'
#' @details This is one of the UI components for the module created to handle all functions related to profiling
#' of experimental data, based on user edits to the fitting parameters of a pre-specified list of
#' reference (target) metabolites. The value provided for 'id' should be identical across the following:
#' profiling_controlsUI(), profiling_trelliscopeUI(), profiling_quantificationUI(), profiling_summaryUI(), and
#' profilingServer().
#'
#' This module component provides the UI element that allow users to:
#' 1) View (within a trelliscope display) the fitted spectra over the sample spectra for all samples and target metabolites
#'
#' @import shiny
#'
profiling_completeviewUI <- function(id){
  ns <- NS(id)
  tagList(
    shinycssloaders::withSpinner(trelliscopejs::trelliscopeOutput(ns("trelliscope"))),
    DT::dataTableOutput(ns("complete_profres_tab"))
  )
}

profiling_detailedviewUI <- function(id){
  ns <- NS(id)

  tagList(
    uiOutput(ns("profvizoptions_ui")),
    shinycssloaders::withSpinner(plotly::plotlyOutput(ns('prof_refmet_view_plot')))
  )
}

#' Module: Server functions specific to metabolite profiling and profiling result generation
#'
#' @param id A string denoting the namespace id.
#' @param xpmt_data A reactive object containing experimental NMR data and associated metadata.
#' @param ref_data A reactive object containing target metabolite data, after having been edited.
#'
#' @details This is the server component for the module created to handle all functions related to profiling
#' of experimental data, based on user edits to the fitting parameters of a pre-specified list of
#' reference (target) metabolites. The value provided for 'id' should be identical across the following:
#' profiling_controlsUI(), profiling_trelliscopeUI(), profiling_quantificationUI(), profiling_summaryUI(), and
#' profilingServer().
#'
#' This module component provides the back-end code that:
#' 1) Performs the profiling for all target metabolites for all sample spectra
#' 2) Generates the trelliscope plot and variety of tables used to visualize and summarize the profiling results
#'
#' @return A reactive object containing a list of two elements. The first element of this list, final_output, is the
#' output of rDolphin's profiling procedure. The second element of the list, reproducibility_data, is some other component
#' generated by rDolphin's profiling procedure. For details, refer to rDolhpin's documentation and/or git repo.

#'
#' @import shiny
#' @importFrom magrittr %>%
#' @importFrom rlang .data
#' @importFrom plyr .
#'
profilingServer <- function(id, xpmt_data, ref_data){
  stopifnot(is.reactive(xpmt_data))
  stopifnot(is.reactive(ref_data))
  moduleServer(id, function(input, output, session){

    output$trelliscope <- trelliscopejs::renderTrelliscope({

      req(user_profiling())

      user_profiling <- user_profiling()
      plot.data <- format_plotting(profiling_data = user_profiling)
      plot.data %>%
        tidyr::nest(data = !one_of(c("Sample", "Metabolite"))) %>%
        dplyr::mutate(
          Quantification = purrr::map_dbl(data, ~ unique(.$Quantification)),
          Signal_Area_Ratio = purrr::map_dbl(data, ~ unique(.$Signal_Area_Ratio)),
          Fitting_Error = purrr::map_dbl(data, ~ unique(.$Fitting_Error)),
          Chemical_Shift = purrr::map_dbl(data, ~ unique(.$Chemical_Shift)),
          Intensity = purrr::map_dbl(data, ~ unique(.$Intensity)),
          Half_Bandwidth = purrr::map_dbl(data, ~ unique(.$Half_Bandwidth)),
          panel = trelliscopejs::map_plot(data, function(x){
            ggplot2::ggplot(data = subset(x, variable != "Quantified Signal"), ggplot2::aes(x = Xdata, y = value, color = variable))+
              ggplot2::geom_line() +
              ggplot2::geom_line(data = subset(x, variable == "Quantified Signal"), ggplot2::aes(x = Xdata, y = value, color=variable), alpha = 0.5)+
              ggplot2::xlab('PPM') + ggplot2::ylab('Intensity') + ggplot2::theme_bw() #+ ggplot2::theme(legend.position = "none")
          })
        ) %>%
        trelliscopejs::trelliscope(name           = "Results",
                                   path           = "www/",
                                   self_contained = TRUE,
                                   state = list(labels = c("Sample", "Metabolite")))

    })

    # complete_profres_tab
    output$complete_profres_tab <- DT::renderDataTable({

      req(user_profiling())

      user_profiling <- user_profiling()

      tempdat_quant <- as.data.frame(user_profiling$final_output$quantification) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Quantity",
                            -.data$Sample)

      tempdat_sar <- as.data.frame(user_profiling$final_output$signal_area_ratio) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Signal to Area Ratio",
                            -.data$Sample)

      tempdat_err <- as.data.frame(user_profiling$final_output$fitting_error) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Fitting Error",
                            -.data$Sample)

      tempdat_cs <- as.data.frame(user_profiling$final_output$chemical_shift) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Fitted Chemical Shift (ppm)",
                            -.data$Sample)

      tempdat_int <- as.data.frame(user_profiling$final_output$intensity) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Fitted Intensity",
                            -.data$Sample)

      tempdat_hbw <- as.data.frame(user_profiling$final_output$half_bandwidth) %>%
        dplyr::mutate(Sample = rownames(.)) %>%
        tidyr::pivot_longer(names_to  = "Metabolite",
                            values_to = "Fitted Half Bandwidth (Hz)",
                            -.data$Sample)

      tempdat <- dplyr::left_join(tempdat_quant, tempdat_err)
      tempdat <- dplyr::left_join(tempdat, tempdat_sar)
      tempdat <- dplyr::left_join(tempdat, tempdat_cs)
      tempdat <- dplyr::left_join(tempdat, tempdat_int)
      tempdat <- dplyr::left_join(tempdat, tempdat_hbw)


      quant_refdata <- ref_data()$user_edited_refdata %>% dplyr::filter(.data$Quantify == 1)
      qmetnames <- unique(quant_refdata$Metabolite)
      for(name in qmetnames){
        tempdat$Metabolite[which(grepl(make.names(name), tempdat$Metabolite))] <- name
      }

      tempdat %>% dplyr::select(.data$Sample, .data$Metabolite, .data$`Fitted Chemical Shift (ppm)`, .data$`Fitted Intensity`,
                                .data$`Fitted Half Bandwidth (Hz)`, .data$`Quantity`, .data$`Fitting Error`,
                                .data$`Signal to Area Ratio`) %>%
        DT::datatable(rownames   = FALSE,
                      filter = "top",
                      extensions = c("Responsive", "Buttons"),
                      options = exprToFunction(
                        list(dom = 'Bf',
                             buttons = list(
                               list(extend = 'csv',
                                    filename =  paste0(lubridate::year(lubridate::now()), "-",
                                                       lubridate::month(lubridate::now()), "-",
                                                       lubridate::day(lubridate::now()), "_",
                                                       "Detailed_Profiling_Results.csv")),
                               list(extend = 'excel',
                                    filename =  paste0(lubridate::year(lubridate::now()), "-",
                                                       lubridate::month(lubridate::now()), "-",
                                                       lubridate::day(lubridate::now()), "_",
                                                       "Detailed_Profiling_Results.xlsx"))))
                      ),
                      class = "display")

    })

    output$profvizoptions_ui <- renderUI({

      req(xpmt_data())
      req(ref_data())

      quant_refdata <- ref_data()$user_edited_refdata %>% dplyr::filter(.data$Quantify == 1)
      qmetnames <- unique(quant_refdata$Metabolite)

      shinyWidgets::dropdownButton(
        # Allows users to select which sample spectrum to display.
        selectInput(inputId = NS(id, "sample_to_plot"),
                    label   = "Choose a spectrum to plot",
                    choices = colnames(xpmt_data()$e_data)[-1]),

        selectInput(inputId = NS(id, "refmet_to_plot"),
                    label   = "Select the metabolite fit(s) to view:",
                    choices = qmetnames),

        actionButton(inputId = NS(id, "view_detailed"),
                     label = "View"),
        h4(),

        # Toggle for subplot display
        shinyWidgets::materialSwitch(inputId = NS(id, "show_subplot"),
                                     label   = "Show subplot on box select",
                                     value   = FALSE,
                                     status  = "primary",
                                     right   = TRUE),

        # HTML output to display the filters currently applied
        htmlOutput(NS(id, "applied_filters_text")),

        circle = TRUE, status = "info",
        icon = icon("cog"), width = "300px",

        tooltip = shinyWidgets::tooltipOptions(title = "Plot Options")
      )
    })

    # Output (in HTML format) to display the filters that are currently applied to the data.
    output$applied_filters_text <- renderUI({

      if(length(attr(xpmt_data(), "filters")) == 0){
        htmltools::HTML("<strong>Currently applied filters:</strong><br/>None")

      } else{
        allfilts <- rlist::list.ungroup(rlist::list.select(attr(xpmt_data(), "filters"), range))
        allfilts <- Reduce("c", lapply(allfilts, function(x){paste0("(", x$min, ", ", x$max, ")")}))
        htmltools::HTML(paste0("<strong>Currently applied filters:</strong><br/>", paste(allfilts, collapse = "<br/>")))

      }
    })

    output$prof_refmet_view_plot <- plotly::renderPlotly({

      req(user_profiling())

      req(xpmt_data())
      req(ref_data())


      input$view_detailed

      isolate({
        profiling_data <- user_profiling()
        req(input$sample_to_plot)
        req(input$refmet_to_plot)

        # Extract indices of reproducibility data that correspond to selected sample and metabolite
        selsamp_ind <- which(rownames(profiling_data$final_output$quantification) == input$sample_to_plot)
        selmet_inds <- which(grepl(make.names(input$refmet_to_plot), colnames(profiling_data$final_output$quantification)))

        ROI_plots <- vector("list", length = length(selmet_inds))
        for(i in 1:length(selmet_inds)){

          tempdat <- profiling_data$reproducibility_data[[selsamp_ind]][[selmet_inds[i]]]

          # If there are no surrounding signals, then tempdat$plot_data should have only four rows. The first
          # row is the summed intensities across all signals (target and surrounding); the second row is
          # the summed intensities across all baseline signals; the third row is the sum of the first and second
          # rows (so effectively the "generated" spectrum based on the signal and background signal fits); and the
          # fourth row is the fitted intensities of the ROI of interest. Subsequent rows would correspond to surrounding
          # signals.
          # Initialize plotdata
          plotdata <- data.frame(PPM                = c(tempdat$Xdata, tempdat$Xdata, tempdat$Xdata, tempdat$Xdata),
                                 Intensity          = c(tempdat$Ydata, tempdat$Ydata, tempdat$Ydata, tempdat$Ydata),
                                 Intensity_Type     = rep(c("Generated", "Signal", "Background", "Surrounding"),
                                                          each = length(tempdat$Xdata)))

          # Update intensities accordingly
          plotdata$Intensity[plotdata$Intensity_Type == "Signal"] <-
            tempdat$plot_data[which(grepl(make.names(input$refmet_to_plot), rownames(tempdat$plot_data))),]
          plotdata$Intensity[plotdata$Intensity_Type == "Background"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "baseline_sum", ]
          plotdata$Intensity[plotdata$Intensity_Type == "Generated"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "fitted_sum", ]
          plotdata$Intensity[plotdata$Intensity_Type == "Surrounding"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "signals_sum", ] - plotdata$Intensity[plotdata$Intensity_Type == "Signal"]
          plotdata$ROI <- i

          ROI_plots[[i]] <- plotdata
        }

        ROI_plots <- Reduce("rbind", ROI_plots)
        ROI_data <- ref_data()$user_edited_refdata %>% dplyr::filter(.data$Quantify == 1)

        # Line shape update
        # Create default line object to add as shape to plot
        ROI_line <- list(
          type = "line",
          line = list(color = "red"),
          xref = "x",
          yref = "y"
        )

        # Create list containing all line objects. For each line object in this list, populate with the
        # ROI information corresponding to the given reference metabolite peak.
        ROI_lines <- list()
        for(i in 1:nrow(ROI_data)){

          ROI_line[["x0"]]        <- ROI_data[i,,drop = FALSE]$"ROI left edge (ppm)"
          ROI_line[["x1"]]        <- ROI_data[i,,drop = FALSE]$"ROI right edge (ppm)"
          ROI_line[c("y0", "y1")] <- 0
          ROI_lines               <- c(ROI_lines, list(ROI_line))
        }

        # Annotation update
        # Create default annot object to add as annotation to plot
        ROI_annot <- list(
          y         = 0,
          xref      = "x",
          yref      = "y",
          arrowhead = 4,
          ay        = 40
        )

        ROI_annots <- list()
        for(i in 1:nrow(ROI_data)){
          ROI_annot[["x"]]         <- ROI_data[i,,drop = FALSE]$"Chemical shift(ppm)"
          ROI_annot[["text"]]      <- paste0(sprintf("<b>%s</b>", "ROI: "),
                                             ROI_data[i,,drop = FALSE]$"Chemical shift(ppm)", " (",
                                             ROI_data[i,,drop = FALSE]$"ROI left edge (ppm)", ", ",
                                             ROI_data[i,,drop = FALSE]$"ROI right edge (ppm)", ")", " <br> ",
                                             sprintf("<b>%s</b>", "Quantification: "), round(profiling_data$final_output$quantification[selsamp_ind, i],3), " <br> ",
                                             sprintf("<b>%s</b>", "Signal to Area Ratio: "), round(profiling_data$final_output$signal_area_ratio[selsamp_ind, i],3), " <br> ",
                                             sprintf("<b>%s</b>", "Fitting Error: "), round(profiling_data$final_output$fitting_error[selsamp_ind, i],3))
          ROI_annot[["arrowsize"]] <- ROI_data[i,,drop = FALSE]$"Chemical shift tolerance (ppm)"
          ROI_annot[["showarrow"]] <- TRUE
          ROI_annots               <- c(ROI_annots, list(ROI_annot))
        }


        xpmt_data_sample <- xpmt_data()$e_data %>% dplyr::select(.data$PPM, .data[[input$sample_to_plot]])
        df_long <- xpmt_data_sample %>%
          tidyr::pivot_longer(!.data$PPM, names_to = "Sample", values_to = "Intensity")

        ROI_plots %>% dplyr::group_by(.data$ROI) %>% plotly::plot_ly(source = "id_prof_refmet_view_plot") %>%
          plotly::config(displaylogo = FALSE,
                         modeBarButtons = list(list("select2d"), list("zoom2d"), list("zoomIn2d"),
                                               list("zoomOut2d"), list("pan2d"), list("autoScale2d"),
                                               list("resetScale2d"), list("toImage"))) %>%
          plotly::layout(title = paste("Experimental Data:", input$sample_to_plot, "<br>", "<sup>",
                                       input$refmet_to_plot, "Region(s) of Interest (ROI) displayed", "</sup>"),
                         xaxis = list(title     = "PPM",
                                      autorange = "reversed"),
                         yaxis = list(title     = "Intensity"),
                         showlegend = TRUE,
                         dragmode = "zoom2d",
                         annotations = ROI_annots,
                         shapes = ROI_lines) %>%
          plotly::config(edits = list(annotationTail     = TRUE,
                                      annotationText     = FALSE,
                                      annotationPosition = FALSE,
                                      shapePosition      = FALSE)) %>%
          plotly::add_trace(x    = df_long$PPM,
                            y    = df_long$Intensity,
                            type = 'scatter',
                            mode = 'lines',
                            line = list(width = 1),
                            opacity = 0.3,
                            hoverinfo = "text",
                            text = paste0("PPM: ", round(df_long$PPM, 4), "<br>",
                                          "Intensity: ", round(df_long$Intensity, 4)),
                            showlegend = FALSE) %>%
          plotly::add_trace(x = ROI_plots$PPM,
                            y = ROI_plots$Intensity,
                            name = ~ROI_plots$Intensity_Type,
                            type = "scatter",
                            mode = "lines",
                            line = list(color = ~ROI_plots$Intensity_Type,
                                        width = 1))
      })


    })

    # Plotting of the subplot of ppm data across all sample spectra at the selected region
    output$prof_refmet_view_subplot <- plotly::renderPlotly({

      req(input$show_subplot)
      req(user_profiling())

      isolate({
        req(xpmt_data())
        req(ref_data())
        req(input$sample_to_plot)
        req(input$refmet_to_plot)
      })

      brushedData <- plotly::event_data("plotly_brushed", source = "id_prof_refmet_view_plot")

      if(is.null(brushedData)){
        return(NULL)
      }

      isolate({


        df_long <- xpmt_data()$e_data %>%
          tidyr::pivot_longer(!.data$PPM, names_to = "Sample", values_to = "Intensity")

        df_long <- df_long %>% dplyr::filter(.data$PPM >= min(brushedData$x), .data$PPM <= max(brushedData$x))
        df_long_selsamp <- df_long %>% dplyr::filter(.data$Sample == input$sample_to_plot)
        df_long_nonselsamp <- df_long %>% dplyr::filter(.data$Sample != input$sample_to_plot)

        profiling_data <- user_profiling()

        # Extract indices of reproducibility data that correspond to selected sample and metabolite
        selsamp_ind <- which(rownames(profiling_data$final_output$quantification) == input$sample_to_plot)
        selmet_inds <- which(grepl(make.names(input$refmet_to_plot), colnames(profiling_data$final_output$quantification)))

        ROI_plots <- vector("list", length = length(selmet_inds))
        for(i in 1:length(selmet_inds)){

          tempdat <- profiling_data$reproducibility_data[[selsamp_ind]][[selmet_inds[i]]]

          # If there are no surrounding signals, then tempdat$plot_data should have only four rows. The first
          # row is the summed intensities across all signals (target and surrounding); the second row is
          # the summed intensities across all baseline signals; the third row is the sum of the first and second
          # rows (so effectively the "generated" spectrum based on the signal and background signal fits); and the
          # fourth row is the fitted intensities of the ROI of interest. Subsequent rows would correspond to surrounding
          # signals.
          # Initialize plotdata
          plotdata <- data.frame(PPM                = c(tempdat$Xdata, tempdat$Xdata, tempdat$Xdata, tempdat$Xdata),
                                 Intensity          = c(tempdat$Ydata, tempdat$Ydata, tempdat$Ydata, tempdat$Ydata),
                                 Intensity_Type     = rep(c("Generated", "Signal", "Background", "Surrounding"),
                                                          each = length(tempdat$Xdata)))

          # Update intensities accordingly
          plotdata$Intensity[plotdata$Intensity_Type == "Signal"] <-
            tempdat$plot_data[which(grepl(make.names(input$refmet_to_plot), rownames(tempdat$plot_data))),]
          plotdata$Intensity[plotdata$Intensity_Type == "Background"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "baseline_sum", ]
          plotdata$Intensity[plotdata$Intensity_Type == "Generated"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "fitted_sum", ]
          plotdata$Intensity[plotdata$Intensity_Type == "Surrounding"] <-
            tempdat$plot_data[rownames(tempdat$plot_data) == "signals_sum", ] - plotdata$Intensity[plotdata$Intensity_Type == "Signal"]
          plotdata$ROI <- i

          ROI_plots[[i]] <- plotdata
        }

        ROI_plots <- Reduce("rbind", ROI_plots)
        ROI_data <- ref_data()$user_edited_refdata %>% dplyr::filter(.data$Quantify == 1)

        # Line shape update
        # Create default line object to add as shape to plot
        ROI_line <- list(
          type = "line",
          line = list(color = "red"),
          xref = "x",
          yref = "y"
        )

        # Create list containing all line objects. For each line object in this list, populate with the
        # ROI information corresponding to the given reference metabolite peak.
        ROI_lines <- list()
        for(i in 1:nrow(ROI_data)){

          ROI_line[["x0"]]        <- ROI_data[i,,drop = FALSE]$"ROI left edge (ppm)"
          ROI_line[["x1"]]        <- ROI_data[i,,drop = FALSE]$"ROI right edge (ppm)"
          ROI_line[c("y0", "y1")] <- 0
          ROI_lines               <- c(ROI_lines, list(ROI_line))
        }

        # Annotation update
        # Create default annot object to add as annotation to plot
        ROI_annot <- list(
          y         = 0,
          xref      = "x",
          yref      = "y",
          arrowhead = 4,
          ay        = 40
        )

        ROI_annots <- list()
        for(i in 1:nrow(ROI_data)){
          ROI_annot[["x"]]         <- ROI_data[i,,drop = FALSE]$"Chemical shift(ppm)"
          ROI_annot[["text"]]      <- paste0(sprintf("<b>%s</b>", "ROI: "),
                                             ROI_data[i,,drop = FALSE]$"Chemical shift(ppm)", " (",
                                             ROI_data[i,,drop = FALSE]$"ROI left edge (ppm)", ", ",
                                             ROI_data[i,,drop = FALSE]$"ROI right edge (ppm)", ")", " <br> ",
                                             sprintf("<b>%s</b>", "Quantification: "), round(profiling_data$final_output$quantification[selsamp_ind, i],3), " <br> ",
                                             sprintf("<b>%s</b>", "Signal to Area Ratio: "), round(profiling_data$final_output$signal_area_ratio[selsamp_ind, i],3), " <br> ",
                                             sprintf("<b>%s</b>", "Fitting Error: "), round(profiling_data$final_output$fitting_error[selsamp_ind, i],3))
          ROI_annot[["arrowsize"]] <- ROI_data[i,,drop = FALSE]$"Chemical shift tolerance (ppm)"
          ROI_annot[["showarrow"]] <- TRUE
          ROI_annots               <- c(ROI_annots, list(ROI_annot))
        }

        # Include only the annotations within the selected range.
        tempidx <- lapply(ROI_lines, function(x){ifelse((x$x0 >= min(brushedData$x) & x$x0 <= max(brushedData$x)) |
                                                          (x$x1 >= min(brushedData$x) & x$x0 <= max(brushedData$x) |
                                                             ((x$x0+x$x1)/2 >= min(brushedData$x) & (x$x0+x$x1)/2 <= max(brushedData$x))),
                                                        TRUE, FALSE)})
        tempidx <- Reduce("c", tempidx)


        ROI_lines <- ROI_lines[tempidx]
        ROI_annots <- ROI_annots[tempidx]
        ROI_plots <- ROI_plots %>% dplyr::filter(.data$ROI %in% which(tempidx))

        ROI_plots %>% dplyr::group_by(.data$ROI) %>% plotly::plot_ly(source = "id_prof_refmet_view_subplot") %>%
          plotly::config(displaylogo = FALSE,
                         modeBarButtons = list(list("zoom2d"), list("zoomIn2d"),
                                               list("zoomOut2d"), list("pan2d"), list("autoScale2d"),
                                               list("resetScale2d"), list("toImage"))) %>%
          plotly::layout(xaxis = list(title     = "PPM",
                                      autorange = "reversed"),
                         yaxis = list(title     = "Intensity"),
                         showlegend = TRUE,
                         dragmode = "zoom2d",
                         annotations = ROI_annots,
                         shapes = ROI_lines) %>%
          plotly::add_trace(data = df_long_selsamp,
                            x=~.data$PPM, y=~.data$Intensity, type = "scatter", mode = "lines", name = input$sample_to_plot,
                            line = list(width = 1.3), hoverinfo = "text",
                            hovertext = paste0("Sample: ", input$sample_to_plot,
                                               "\nPPM: ", round(df_long_selsamp$PPM, 4),
                                               "\nIntensity: ", round(df_long_selsamp$Intensity, 4))) %>%
          plotly::add_trace(data = df_long_nonselsamp,
                            x=~.data$PPM, y=~.data$Intensity, type = "scatter", name = ~.data$Sample,
                            opacity = 0.3, mode = "lines", line = list(color = "#000000", width = 0.75),
                            hoverinfo = "text", hovertext = paste0("Sample: ", df_long_nonselsamp$Sample,
                                                                   "\nPPM: ", round(df_long_nonselsamp$PPM, 4),
                                                                   "\nIntensity: ", round(df_long_nonselsamp$Intensity, 4)),
                            showlegend = FALSE) %>%
          plotly::add_trace(x = ROI_plots$PPM,
                            y = ROI_plots$Intensity,
                            name = ~ROI_plots$Intensity_Type,
                            type = "scatter",
                            mode = "lines",
                            line = list(color = ~ROI_plots$Intensity_Type,
                                        width = 1)) %>%
          plotly::config(edits = list(annotationTail     = TRUE,
                                      annotationText     = FALSE,
                                      annotationPosition = FALSE,
                                      shapePosition      = FALSE))

      })

    })

    # Observer to control pop-up (i.e. modal) containing the subplot of spectral data at a selected region.
    # Note: This works fine, but the only thing that I would like to change is
    # loading of subsequent plots generated by different brush events.
    # On initial plot, the loading spinner shows, but on subsequent plots, it does not.
    # Not sure how to fix this yet, but I suspect the issue lies in the execution order.
    # This observer triggers before "e_data_subplot" invalidates.
    observeEvent(plotly::event_data("plotly_brushed", source = "id_prof_refmet_view_plot"),{
      req(input$show_subplot)

      brushedData <- plotly::event_data("plotly_brushed", source = "id_prof_refmet_view_plot")

      removeModal()
      showModal(
        modalDialog(
          shinycssloaders::withSpinner(plotly::plotlyOutput(NS(id, 'prof_refmet_view_subplot'))),
          title = paste0("All Sample Spectra: ", round(min(brushedData$x),3)," PPM to ", round(max(brushedData$x),3), " PPM"),
          size = "xl",
          easyClose = TRUE,
          fade = FALSE
        ))
    })

    user_profiling <- eventReactive(ref_data()$profile_confirm,{
      req(xpmt_data())
      req(ref_data()$profile_confirm == TRUE)

      shinyWidgets::progressSweetAlert(
        session = session,
        id = "profiling_progress",
        value = 0, title = "",
        display_pct = TRUE, striped = TRUE, status = "info"
      )

      shinyWidgets::updateProgressBar(
        session = session,
        id = "profiling_progress",
        title = "Importing and processing necessary data to begin the profiling...",
        value = 0
      )

      #formats the data object
      imported_data <- ppmData_to_rDolphin(ppmData = xpmt_data(),
                                                        metabs  = ref_data()$user_edited_refdata %>% dplyr::filter(.data$Quantify == 1))
      # In the above (metabs), we exclude the peaks designated by the user to remove from quantification (Quantify == 0).

      # Don't think we need since we apply filtering earlier to vreate xpmt_data()
      # if(xpmt_data_mods()$filter_status){
      #   #Filter selected region
      #   imported_data <- filter_ppm(imported_data = imported_data,
      #                                            range         = list(min = min(as.numeric(xpmt_data_mods()$filter_range)),
      #                                                                 max = max(as.numeric(xpmt_data_mods()$filter_range))))
      # }

      ROI_data           = imported_data$ROI_data
      optimization       = TRUE
      spectra_to_profile = NULL

      # Begin direct pull from rDolphin source code.
      # We pull directly from source so that we could generate progress bars
      signals_names <- make.names(paste(ROI_data[,4], ROI_data[,5], sep='_'))
      dummy <- matrix(NaN, nrow(imported_data$dataset), length(signals_names),
                      dimnames = list(imported_data$Experiments, signals_names))

      final_output <- list(quantification    = dummy,
                           signal_area_ratio = dummy,
                           fitting_error     = dummy,
                           chemical_shift    = dummy,
                           intensity         = dummy,
                           half_bandwidth    = dummy)

      #creation of list of necessary parameters to load quantifications and evaluate quality of them
      reproducibility_data <- vector('list', length(imported_data$Experiments))

      for (i in seq_along(reproducibility_data)){
        reproducibility_data[[i]] <- vector('list',length(signals_names))
      }
      for (i in seq_along(reproducibility_data)) {
        for (j in seq_along(reproducibility_data[[i]])) {
          reproducibility_data[[i]][[j]] <- list(Ydata              = NULL,
                                                 Xdata              = NULL,
                                                 ROI_profile        = imported_data$ROI_data[j,],
                                                 program_parameters = NULL,
                                                 plot_data          = NULL,
                                                 FeaturesMatrix     = NULL,
                                                 signals_parameters = NULL,
                                                 results_to_save    = NULL,
                                                 error1             = 1000000)
        }}

      #Splitting of ROI data into individual ROIs to be quantified
      dummy <- which(is.na(ROI_data[, 1]))

      if (length(dummy) == 0){
        dummy <- dim(ROI_data)[1]+1
      }
      lal <- which(duplicated(ROI_data[-dummy,1:2]) == F)
      ROI_separator <-cbind(lal, c(lal[-1] - 1, dim(ROI_data[-dummy,])[1]))

      baselinedataset <- baseline::baseline.rollingBall(imported_data$dataset,5,5)$baseline

      #For every ROI
      totit <- max(seq_along(ROI_separator[, 1]))*nrow(imported_data$dataset)
      sumit <- 0
      for (ROI_index in seq_along(ROI_separator[, 1])) {

        #Preparation of ROI parameters
        ROI_profile <- ROI_data[ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2],]
        ROI_buckets <- which.min(abs(as.numeric(ROI_profile[1, 1]) - imported_data$ppm)):which.min(abs(as.numeric(ROI_profile[1, 2]) - imported_data$ppm))

        if (length(ROI_buckets)<20) {
          sumit <- sumit + nrow(imported_data$dataset)
          shinyWidgets::updateProgressBar(
            session = session,
            id      = "profiling_progress",
            title   = paste0("Ignoring ROI as width is too small"),
            value   = trunc(sumit/totit*100)
          )
          next
        }
        if (ROI_buckets[1]>ROI_buckets[2]){
          ROI_buckets <- rev(ROI_buckets)
        }


        #Preparation of program parameters to be sued during fitting, with some variables added to ease interpretability of code
        program_parameters             <- imported_data$program_parameters
        program_parameters$freq        <- imported_data$freq
        program_parameters$ROI_buckets <- ROI_buckets
        program_parameters$buck_step   <- imported_data$buck_step

        Xdata        <- imported_data$ppm[ROI_buckets]
        fitting_type <- as.character(ROI_profile[1, 3])
        if (length(grep("Clean",fitting_type)) == 1) {
          program_parameters$clean_fit <- "Y"
        } else {
          program_parameters$clean_fit <- "N"
        }
        signals_to_quantify <- which(ROI_profile[, 5] >= 1)
        signals_codes       <- (ROI_separator[ROI_index, 1]:ROI_separator[ROI_index, 2])


        #Quantification for every spectrum
        if (is.null(spectra_to_profile)){
          spectra_to_profile <- 1:nrow(imported_data$dataset)
        }

        for (spectrum_index in spectra_to_profile) {
          shinyWidgets::updateProgressBar(
            session = session,
            id      = "profiling_progress",
            title   = paste0('Profiling ROI ', ROI_index, ' of ', nrow(ROI_separator),
                             " for Spectrum ", spectrum_index, " of ",
                             nrow(imported_data$dataset)),
            value   = trunc(sumit/totit*100)
          )
          # THIS IS A TEMPORARY SOLUTION. THE PERMANENT SOLUTION IS TO FORK
          # RDOLPHIN, ADAPT CODE AS NECESSARY, AND PROPERLY CITE THE ORIGINAL AUTHOR
          # OF RDOLPHIN
          profiling_func <- utils::getFromNamespace("profiling_func", "rDolphin")
          output=profiling_func(spectrum_index, signals_codes,
                                imported_data,
                                ROI_buckets, fitting_type,
                                program_parameters, Xdata, Ydata = NULL,
                                final_output,
                                reproducibility_data,
                                ROI_profile, baselinedataset,
                                signals_to_quantify,
                                pb = NULL)
          # profiling_func() is an internal rDolphin function that is not
          # meant to be accessed by the user.
          # Note that Ydata is internally defined by profiling function despite
          # what is supplied to the argument above. See automatic_profiling.R and
          # profiling_func().
          final_output <- output$final_output
          reproducibility_data <- output$reproducibility_data
          sumit <- sumit + 1
        }
      }
      shinyWidgets::closeSweetAlert(session = session)

      tryCatch({
        if (optimization == TRUE & length(spectra_to_profile) > 20 & nrow(ROI_data) > 20) {
          optimized_profiling_data <-
            rDolphin::automatic_profiling_improv(imported_data,
                                                 final_output,
                                                 reproducibility_data,
                                                 ROI_data)
          nn <- optimized_profiling_data$final_output$fitting_error - final_output$fitting_error
          no <- grDevices::boxplot.stats(nn)$stats[5]
          ind <- which(nn>no)

          for (i in 1:length(optimized_profiling_data$final_output)) {
            optimized_profiling_data$final_output[[i]][ind] <- final_output[[i]][ind]
          }
          for (i in 1:nrow(optimized_profiling_data$final_output$fitting_error)) {
            ind <- which(nn[i,] > no)
            if (length(ind) > 0){
              optimized_profiling_data$reproducibility_data[[i]][ind] <- reproducibility_data[[i]][ind]
            }
          }
          final_output <- optimized_profiling_data$final_output
          reproducibility_data <- optimized_profiling_data$reproducibility_data
        }
      }, error = function(e)NA)

      profiling_data <- list(final_output         = final_output,
                             reproducibility_data = reproducibility_data)

      all_profiling_results <- profiling_data

      return(all_profiling_results)
    })

  })
}
